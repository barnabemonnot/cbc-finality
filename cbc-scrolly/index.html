<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="general.css"/>
    <link rel="stylesheet" type="text/css" href="index.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <script src="libs/katex/katex.min.js"></script>
    <script src="libs/underscore.min.js"></script>
    <script src="libs/react.development.js"></script>
    <script src="libs/react-dom.development.js"></script>
    <script src="libs/d3v4+jetpack.js"></script>
    <script src="libs/graph-scroll.js"></script>
    <script src="hack.js"></script>
    <script src="src/component-library.js"></script>
  </head>
  <body>
    <div class="document-container">
      <div class="title-container">
        <div class="title">
          Finality in CBC Casper
        </div>
        <div class="sub-title">
      	  Checking for finality in a set of messages.
      	</div>
      </div>

      <section class="abstract">
        On to the finals!!!
      </section>

      <div id="toc-author-block" style="display: flex">
        <div id="authors"></div>
        <div id="toc"></div>
      </div>
    </div>
    <div>

      <section class="introduction">

	<div>
	  <h2>Here is the problem</h2>
	  In blockchains we care about adding some notion of “finality” - the idea that some block can be so firmly established in the chain that it cannot be overtaken by a competing block unless a very large portion (eg. 1/4) of validators commit a uniquely attributable fault - act in some way which is clearly and cryptographically verifiably malicious.
	</div>

	<div>
	  <h2>Here's why it's interesting</h2>
	  Finality is a very significant advancement: once a block is finalized, it is secure regardless of network latency (unlike confirmations in PoW), and reverting the block requires >= x% of validators to cheat in a way that's detectable and can be used to destroy their deposits.
	  <p>
	    There are many different approaches to finality, but the two important ones within the ethereum ecosystem are Casper FFG and Casper CBC. Here we'll be focusing on CBC
	  </p>
	</div>

	<div>
	  <h2>What exactly are we focusing on?</h2>
	  Specifically, we'll be implementing a finality oracle -- a set of heuristics that allow us to detect some of the cases where a block is final under CBC Casper.
	  <p>
	    But before we do that, let's take a look at why finality is not trivial to detect.
	  </p>
	</div>

      </section>

      <div class="scroll-container">

	<div id="graph">
	  <svg id="intro-svg" viewBox="0 0 400 300"></svg>
	</div>

	<div id="scroll-sections">
	  <div class="epoch">
	    Imagine we have three nodes -- A, B and C -- executing a simple binary consensus protocol -- in other words sending messages containing either 0 or 1. And imagine we are using the following intuitive (but alas incorrect) finality oracle: a value is finalized if all nodes propose that same value in their latest messages.
	  </div>

	  <div class="epoch">
	  </div>

	  <div class="epoch">
	  </div>

	  <div class="epoch">
	  </div>

	  <div class="epoch">
	  </div>

	  <div class="epoch">
	  </div>

	  <div class="epoch">
	  </div>

	  <div class="epoch">
	  </div>

	  <div class="epoch">
	  </div>

	  <div class="epoch">
	  </div>

	</div>
      </div>
    </div>

    <div class="document-container">
      <div class="section-title section-label">
        The finality test
      </div>

      <div class="section-sub-title section-label">
        A simple test
      </div>

      <div class="content">
        The introduction presented a situation where validators cannot agree while all are honest and a majority exists. We then require the following property: for all validators to agree on a value, and acknowledge that they have seen everyone agree with that value. In the following, we present a test to detect the presence of a <strong>quorum</strong> of validators satisfying this property.
      </div>

      <div class="content">
        Let us introduce the objects in our discussion. Validators send messages <span class="math">m</span>, with the general pattern of a message given by <span class="math">m = (c, v, \sigma)</span>, with:
      	  <ul>
            <li><strong>The estimate</strong> <span class="math">c</span>: a consensus value among all possible values <span class="math">\mathcal{C}</span>. In this article, we consider only binary consensus, where <span class="math">\mathcal{C} = \{ 0, 1 \}.</span></li>
      	    <li><strong>The sender</strong> <span class="math">v</span>: a reference to a validator from the set <span class="math">\mathcal{V}</span>.</li>
      	    <li><strong>The justification</strong> <span class="math">\sigma</span>: a reference to some protocol state <span class="math">\sigma</span>, i.e., a set of messages that the validator acknowledges.</li>
      </div>

      <div class="content">
        We would be happy to find, for an integer <span class="math">q</span>, a set of validators where each validator from that set
        <ol>
          <li>Estimates the same consensus value <span class="math">c</span>.</li>
          <li>Has acknowledged that (i.e., included in its justification) at least <span class="math">q</span> other validators from that set has estimated <span class="math">c</span>.</li>
          <li>These included validators have kept on estimating the value<span class="math">c</span>.</li>
        </ol>
      </div>

      <div class="content">
        Suppose we have the following bipartite graph, where we trace an edge between two validators <span class="math">A</span> and <span class="math">B</span> if <span class="math">A</span> has included a message from <span class="math">B</span> in its latest justification where <span class="math">B</span> estimates the same value as <span class="math">A</span>.
      </div>

      <div id="img-four-validators"></div>
    	<script>
    	ReactDOM.render(
    	  React.createElement(
    	    StaticImage, {
    	      src: 'img/simpletest.png',
    	      name: 'The acknowledgement graph of 4 validators.'
    	    },
          "In this graph, a validator ",
          e("span", { className: "math" }, "x"),
          " on the left connects to a validator ",
          e("span", { className: "math" }, "y"),
          " on the right if ",
          e("span", { className: "math" }, "x"),
          " has acknowledged in its latest justification a message from ",
          e("span", { className: "math" }, "y"),
          " which estimates the same value as ",
          e("span", { className: "math" }, "x"),
          "'s. In other words, ",
          e("span", { className: "math" }, "x"),
          " and ",
          e("span", { className: "math" }, "y"),
          " agree, and ",
          e("span", { className: "math" }, "x"),
          " knows they agree. A validator agrees with itself as long as it has posted at least one message."
    	  ), document.querySelector('#img-four-validators')
    	);
    	</script>

      <div class="content">
        If we set our quorum to be <span class="math">q = 2</span>, then the finality test in the previous example returns positive. <span class="math">A</span> and <span class="math">B</span> agree, and both acknowledge that they agree. For a quorum <span class="math">q = 3</span>, that is not the case and the finality test returns negative.
      </div>

      <div class="section-sub-title section-label">
        Equivocation
      </div>

      <div class="content">
        In the previous example, we assumed validators behaved well and none had equivocated, i.e., sent conflicting messages. Suppose a validator <span class="math">A</span> sends two messages estimating two different values 0 and 1, and neither references the other in its justification. Effectively, the validator has now two latest messages, since neither comes after the other, where order is obtained by saying <span class="math">m</span> arrived after <span class="math">m'</span> if the justification of <span class="math">m</span> contains <span class="math">m'</span>.
      </div>

      <div class="content">
        Equivocation complicates finality seriously, since nodes who acknowledge one message from the malicious validator may be final on a value different from nodes who acknowledged the opposite value from the equivocating message. Before building the acknowledgement graph above, validators who equivocated are removed from the messages log.
      </div>

      <div class="section-sub-title section-label">
        A finer test
      </div>

      <div class="content">
        The previous test looks for an acknowledgement graph one layer deep, where validators acknowledge a message from other validators that matches their own estimate. One can have a stronger guarantee on finality by requiring more layers to be acknowledged. In the following, we set the quorum at <span class="math">q</span>.
      </div>

      <div class="content">
        A message <span class="math">m</span> is at <strong>level 0</strong> on consensus value <span class="math">c</span> if it estimates <span class="math">c</span> and all later messages from the same sender also estimate <span class="math">c</span>.
      </div>

      <div class="content">
        A message <span class="math">m</span> is at <strong>level <span class="math">k+1</span></strong> on consensus value <span class="math">c</span> if
        <ul>
          <li>It is at level 0 on <span class="math">c</span>,</li>
          <li>At least <span class="math">q</span> messages in the justification of <span class="math">m</span> are at level <span class="math">k</span> on <span class="math">c</span>.</li>
        </ul>
      </div>

      <div id="img-levelk"></div>
    	<script>
    	ReactDOM.render(
    	  React.createElement(
    	    StaticImage, {
    	      src: 'img/levelk.png',
    	      name: 'An acknowledgement graph of 3 validators.'
    	    },
          "A, B and C send messages, all estimating 0, represented as circles. Edges show a source message has acknowledged a target message (at the end of the arrow). We will compute step-by-step the level of each message on value 0, for a quorum ",
          e("span", { className: "math" }, "q = 2"),
          "."
    	  ), document.querySelector('#img-levelk')
    	);
    	</script>

      <div id="img-levelk0"></div>
    	<script>
    	ReactDOM.render(
    	  React.createElement(
    	    StaticImage, {
    	      src: 'img/levelk0.png',
    	      name: 'Level 0 messages.'
    	    },
          "All messages are level 0 on value 0, since all future messages (or none of them if there is no future message) also estimates 0."
    	  ), document.querySelector('#img-levelk0')
    	);
    	</script>

      <div id="img-levelk1"></div>
    	<script>
    	ReactDOM.render(
    	  React.createElement(
    	    StaticImage, {
    	      src: 'img/levelk1.png',
    	      name: 'Level 1 messages.'
    	    },
          "Messages acknowledging at least two level 0 messages are level 1 at consensus value 0."
    	  ), document.querySelector('#img-levelk1')
    	);
    	</script>

      <div id="img-levelk2"></div>
    	<script>
    	ReactDOM.render(
    	  React.createElement(
    	    StaticImage, {
    	      src: 'img/levelk2.png',
    	      name: 'Level 2 messages.'
    	    },
          "Messages acknowledging at least two level 1 messages are level 2 at consensus value 0."
    	  ), document.querySelector('#img-levelk2')
    	);
    	</script>

      <div class="content">
        Finally, a set <span class="math">S</span> of validators is <span class="math">(q, k)</span>-good on <span class="math">c</span> if there is a level <span class="math">k</span> message for each validator, where the levels are computed on validators from this set <span class="math">S</span> <em>only</em>.
        This means that the <span class="math">q</span> messages at each level must come only from validators in <span class="math">S</span>.
      </div>

      <div class="section-sub-title section-label">
        Setting the quorum
      </div>

      <div class="content">
        We left unresolved the question of how to set the quorum and will not expand much here. Of course, the quorum makes the requirement for the finality test to return positive more or less stringent. Setting <span class="math">q</span> above half the number of validators guarantees safety in the following way.
      </div>

      <div class="content">
        Suppose in a future state majority changes after the finality test had returned positive. Clearly someone must have changed their mind since with a <span class="math">q</span> above half the number of validators, the test guarantees the finality of the decision for future states. The validator who changed its mind must have equivocated and the fault is attributable by exhibiting equivocating messages. The quorum <span class="math">q</span> and the level <span class="math">k</span> provide bounds on how many validators must have changed their mind to destroy finality.
      </div>
    </div>

    <script>
    let authorData = [{
      name: "Aditya Asgaonkar",
      affiliation: "Ethereum Foundation"
    }, {
      name: "Barnabé Monnot",
      affiliation: "hackingresear.ch"
    }, {
      name: "Sacha Yves Saint-Léger",
      affiliation: "hackingresear.ch"
    }]
    </script>
    <script src="src/authorFormatting.js"></script>
    <script src="src/sectionFormatting.js"></script>
    <script src="src/referencesFormatting.js"></script>
    <script src="src/figureFormatting.js"></script>
    <script src="src/mathFormatting.js"></script>
  </body>
</html>
